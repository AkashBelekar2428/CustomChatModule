//
//  Extensions.swift
//  Peeks
//
//  Created by Nishu Sharma on 06/04/22.
//  Copyright Â© 2022 Riavera. All rights reserved.
//

import Foundation
import UIKit

extension UIFont {
    //Regular
    class func Roboto12_Reg() -> UIFont { return UIFont(name: "Roboto-Regular", size: 12)! }
    class func Roboto14_Reg() -> UIFont { return UIFont(name: "Roboto-Regular", size: 14)! }
    class func Roboto16_Reg() -> UIFont { return UIFont(name: "Roboto-Regular", size: 16)! }
    class func Roboto18_Reg() -> UIFont { return UIFont(name: "Roboto-Regular", size: 18)! }
    class func Roboto20_Reg() -> UIFont { return UIFont(name: "Roboto-Regular", size: 20)! }
    class func Roboto22_Reg() -> UIFont { return UIFont(name: "Roboto-Regular", size: 22)! }
    class func Roboto24_Reg() -> UIFont { return UIFont(name: "Roboto-Regular", size: 24)! }
    class func Roboto_Reg_Size(size: CGFloat) -> UIFont { return UIFont(name: "Roboto-Regular", size: size)! }
    
    // Medium
    class func Roboto14_Medium() -> UIFont { return UIFont(name: "Roboto-Medium", size: 14)! }
    class func Roboto16_Medium() -> UIFont { return UIFont(name: "Roboto-Medium", size: 16)! }
    class func Roboto18_Medium() -> UIFont { return UIFont(name: "Roboto-Medium", size: 18)! }
    class func Roboto20_Medium() -> UIFont { return UIFont(name: "Roboto-Medium", size: 20)! }
    class func Roboto22_Medium() -> UIFont { return UIFont(name: "Roboto-Medium", size: 22)! }
    class func Roboto24_Medium() -> UIFont { return UIFont(name: "Roboto-Medium", size: 24)! }
    class func Roboto_Medium_Size(size: CGFloat) -> UIFont { return UIFont(name: "Roboto-Medium", size: size)! }
    
    // Bold
    class func Roboto12_Bold() -> UIFont { return UIFont(name: "Roboto-Bold", size: 12)! }
    class func Roboto14_Bold() -> UIFont { return UIFont(name: "Roboto-Bold", size: 14)! }
    class func Roboto16_Bold() -> UIFont { return UIFont(name: "Roboto-Bold", size: 16)! }
    class func Roboto18_Bold() -> UIFont { return UIFont(name: "Roboto-Bold", size: 18)! }
    class func Roboto20_Bold() -> UIFont { return UIFont(name: "Roboto-Bold", size: 20)! }
    class func Roboto22_Bold() -> UIFont { return UIFont(name: "Roboto-Bold", size: 22)! }
    class func Roboto24_Bold() -> UIFont { return UIFont(name: "Roboto-Bold", size: 24)! }
    class func Roboto_Bold_Size(size: CGFloat) -> UIFont { return UIFont(name: "Roboto-Bold", size: size)! }
    
    // Black
    class func Roboto14_Black() -> UIFont { return UIFont(name: "Roboto-Black", size: 14)! }
    class func Roboto16_Black() -> UIFont { return UIFont(name: "Roboto-Black", size: 16)! }
    class func Roboto18_Black() -> UIFont { return UIFont(name: "Roboto-Black", size: 18)! }
    class func Roboto20_Black() -> UIFont { return UIFont(name: "Roboto-Black", size: 20)! }
    class func Roboto22_Black() -> UIFont { return UIFont(name: "Roboto-Black", size: 22)! }
    class func Roboto24_Black() -> UIFont { return UIFont(name: "Roboto-Black", size: 24)! }
    class func Roboto_Black_Size(size: CGFloat) -> UIFont { return UIFont(name: "Roboto-Black", size: size)! }
        
    //Regular
    class func Poppins_Reg() -> UIFont { return UIFont(name: "Poppins-Regular", size: 14)! }
    class func Poppins16_Reg() -> UIFont { return UIFont(name: "Poppins-Regular", size: 16)! }
    class func Poppins18_Reg() -> UIFont { return UIFont(name: "Poppins-Regular", size: 18)! }
    class func Poppins20_Reg() -> UIFont { return UIFont(name: "Poppins-Regular", size: 20)! }
    class func Poppins22_Reg() -> UIFont { return UIFont(name: "Poppins-Regular", size: 22)! }
    class func Poppins24_Reg() -> UIFont { return UIFont(name: "Poppins-Regular", size: 24)! }
    class func Poppins_Reg_Size(size: CGFloat) -> UIFont { return UIFont(name: "Poppins-Regular", size: size)! }
    
    // Medium
    class func Poppins14_Medium() -> UIFont { return UIFont(name: "Poppins-Medium", size: 14)! }
    class func Poppins16_Medium() -> UIFont { return UIFont(name: "Poppins-Medium", size: 16)! }
    class func Poppins18_Medium() -> UIFont { return UIFont(name: "Poppins-Medium", size: 18)! }
    class func Poppins20_Medium() -> UIFont { return UIFont(name: "Poppins-Medium", size: 20)! }
    class func Poppins22_Medium() -> UIFont { return UIFont(name: "Poppins-Medium", size: 22)! }
    class func Poppins24_Medium() -> UIFont { return UIFont(name: "Poppins-Medium", size: 24)! }
    class func Poppins_Medium_Size(size: CGFloat) -> UIFont { return UIFont(name: "Poppins-Medium", size: size)! }
    
    // Bold
    class func Poppins14_SemiBold() -> UIFont { return UIFont(name: "Poppins-SemiBold", size: 14)! }
    class func Poppins16_SemiBold() -> UIFont { return UIFont(name: "Poppins-SemiBold", size: 16)! }
    class func Poppins18_SemiBold() -> UIFont { return UIFont(name: "Poppins-SemiBold", size: 18)! }
    class func Poppins20_SemiBold() -> UIFont { return UIFont(name: "Poppins-SemiBold", size: 20)! }
    class func Poppins22_SemiBold() -> UIFont { return UIFont(name: "Poppins-SemiBold", size: 22)! }
    class func Poppins24_SemiBold() -> UIFont { return UIFont(name: "Poppins-SemiBold", size: 24)! }
    class func Poppins_SemiBold_Size(size: CGFloat) -> UIFont { return UIFont(name: "Roboto-SemiBold", size: size)! }
    
    class func MiitvIconFont(size: CGFloat) -> UIFont { return UIFont(name: "miitv-font-file", size: size)! }
}

extension UIColor {
    //MiiTV colors
    static func MiiTV_BGColor() -> UIColor { return UIColor.init(hexString: "#F4F5F9")! }
    static func MiiTV_Black() -> UIColor { return UIColor.init(hexString: "#21293A")! }
    static func MiiTV_LightBlack() -> UIColor { return UIColor.init(hexString: "#222B45")! }
    static func MiiTV_Gray() -> UIColor { return UIColor.init(hexString: "#8E99AF")! }
    static func MiiTV_White() -> UIColor { return UIColor.init(hexString: "#ffffff")! }
    
    static func MiiTV_ThemeClr() -> UIColor { return UIColor.init(hexString: "#FF3D71")! }
    static func MiiTV_DarkPinkClr() -> UIColor { return UIColor.init(hexString: "#F32677")! }
    static func MiiTV_MediumPinkClr() -> UIColor { return UIColor.init(hexString: "#F83E73")! }
    static func MiiTV_LightPinkClr() -> UIColor { return UIColor.init(hexString: "#FB6580")! }
    static func MiiTV_VioletClr() -> UIColor { return UIColor.init(hexString: "#FB6580")! }
    static func MiiTV_BlackClr() -> UIColor { return UIColor.init(hexString: "#21212E")! }
    static func MiiTV_Gray1Clr() -> UIColor { return UIColor.init(hexString: "#727C8E")! }
    static func MiiTV_Gray2Clr() -> UIColor { return UIColor.init(hexString: "#7B7B8B")! }
    static func MiiTV_Gray3Clr() -> UIColor { return UIColor.init(hexString: "#7B7B89")! }
    static func MiiTV_ThinGrayClr() -> UIColor { return UIColor.init(hexString: "#EEF0F6")! }
    static func MiiTV_BtnGrey() -> UIColor { return UIColor.init(hexString: "#C5CEE0")!}
    static func MiiTV_DarkBlack() -> UIColor { return UIColor.init(hexString: "#141E3A")!}
    static func MiiTV_SkyBlue() -> UIColor { return UIColor.init(hexString: "#23E3F9")!}
    static func MiiTV_ChatGrey() -> UIColor { return UIColor(hexString: "#C5CEE0")?.withAlphaComponent(0.29) ?? UIColor.gray}
}

class IconFontManager {
    static let icon_add_user         = "\u{e935}"
    static let icon_menu             = "\u{e936}"
    static let icon_live_tv          = "\u{e937}"
    static let icon_smart_display    = "\u{e938}"
    static let icon_subscription     = "\u{e939}"
    static let icon_trending_up      = "\u{e93a}"
    static let icon_app_logo         = "\u{e919}"
    static let icon_3Dots            = "\u{e91b}"
    static let icon_left_arrow       = "\u{e915}"
    static let icon_right_arrow       = "\u{e954}"
    static let icon_search           = "\u{e926}"
    static let icon_flashOff         = "\u{e953}"
    static let icon_flashOn          = "\u{e928}"
    static let icon_Cross            = "\u{e93c}"
    static let icon_SwitchCamera     = "\u{e948}"
    static let icon_Share_Upload     = "\u{e959}"
    static let icon_Fire             = "\u{e956}"
    static let icon_Close            = "\u{e90a}"
    static let icon_info             = "\u{e95e}"
    static let icon_FullScreen       = "\u{e965}"
    static let icon_AspectScreen     = "\u{e964}"
    static let icon_Plus             = "\u{e920}"
    static let icon_Check            = "\u{e908}"
    static let icon_RemoveFollower   = "\u{e946}"
    static let icon_Story            = "\u{e967}"
    static let icon_Check_Circle     = "\u{e907}"
    static let icon_Uncheck_Circle   = "\u{e969}"
    static let icon_Circle_Filled    = "\u{e909}"
    static let icon_Video_Camera     = "\u{e96a}"
    static let icon_Video_Reply      = "\u{e970}"
    static let icon_Eye_Open         = "\u{e941}"
    static let icon_Like_Filled      = "\u{e916}"
    static let icon_Bright_flash     = "\u{e906}"
    static let icon_Like_Hollow      = "\u{e977}"
    static let icon_Square_Filled    = "\u{e923}"
    static let icon_Eye              = "\u{e96e}"
    static let icon_Eye_Off          = "\u{e96d}"
    static let icon_Timer            = "\u{e978}"   
    static let icon_Live_Stream      = "\u{e979}"   
    static let icon_Show_Playback_Control  = "\u{e97b}"
    static let icon_Hide_Playback_Control  = "\u{e97a}"
    static let icon_Landscape_fullscreen   = "\u{e94c}"
    static let icon_FullScreen_Close       = "\u{e94b}"
    
}

// Global Functions
func AddThemeToButton(btn : UIButton , titles : String , color:UIColor , size : CGFloat) {
    btn.setImage(UIImage(), for: .normal)
    btn.titleLabel?.font = UIFont(name: "miitv-font-file", size: size)
    btn.setTitleColor(color, for: .normal)
    btn.setTitle(titles, for: .normal)
}
extension Int {
    /// EZSE: Checks if the integer is even.
    public var isEven: Bool { return (self % 2 == 0) }

    /// EZSE: Checks if the integer is odd.
    public var isOdd: Bool { return (self % 2 != 0) }

    /// EZSE: Checks if the integer is positive.
    public var isPositive: Bool { return (self > 0) }

    /// EZSE: Checks if the integer is negative.
    public var isNegative: Bool { return (self < 0) }

    /// EZSE: Converts integer value to Double.
    public var toDouble: Double { return Double(self) }

    /// EZSE: Converts integer value to Float.
    public var toFloat: Float { return Float(self) }

    /// EZSE: Converts integer value to CGFloat.
    public var toCGFloat: CGFloat { return CGFloat(self) }

    /// EZSE: Converts integer value to String.
    public var toString: String { return String(self) }

    /// EZSE: Converts integer value to UInt.
    public var toUInt: UInt { return UInt(self) }

    /// EZSE: Converts integer value to Int32.
    public var toInt32: Int32 { return Int32(self) }

    /// EZSE: Converts integer value to a 0..<Int range. Useful in for loops.
    public var range: CountableRange<Int> { return 0..<self }

    /// EZSE: Returns number of digits in the integer.
    public var digits: Int {
        if self == 0 {
            return 1
        } else if Int(fabs(Double(self))) <= LONG_MAX {
            return Int(log10(fabs(Double(self)))) + 1
        } else {
            return -1; //out of bound
        }
    }
    
    /// EZSE: The digits of an integer represented in an array(from most significant to least).
    /// This method ignores leading zeros and sign
    public var digitArray: [Int] {
        var digits = [Int]()
        for char in self.toString {
            if let digit = Int(String(char)) {
                digits.append(digit)
            }
        }
        return digits
    }

    /// EZSE: Returns a random integer number in the range min...max, inclusive.
    public static func random(within: Range<Int>) -> Int {
        let delta = within.upperBound - within.lowerBound
        return within.lowerBound + Int(arc4random_uniform(UInt32(delta)))
    }
}

extension NSMutableData {
    
    /// Append string to NSMutableData
    ///
    /// Rather than littering my code with calls to `dataUsingEncoding` to convert strings to NSData,
    //and then add that data to the NSMutableData,
    //this wraps it in a nice convenient little extension to NSMutableData. This converts using UTF-8.
    ///
    /// - parameter string:       The string to be added to the `NSMutableData`.
    
    func appendString(_ string: String) {
        let data = string.data(using: String.Encoding.utf8, allowLossyConversion: true)
        append(data!)
    }
}

extension String {
    /// EZSE: Init string with a base64 encoded string
    init ? (base64: String) {
        let pad = String(repeating: "=", count: base64.length % 4)
        let base64Padded = base64 + pad
        if let decodedData = Data(base64Encoded: base64Padded, options: NSData.Base64DecodingOptions(rawValue: 0)), let decodedString = NSString(data: decodedData, encoding: String.Encoding.utf8.rawValue) {
            self.init(decodedString)
            return
        }
        return nil
    }
    
    /// EZSE: base64 encoded of string
    var base64: String {
        let plainData = (self as NSString).data(using: String.Encoding.utf8.rawValue)
        let base64String = plainData!.base64EncodedString(options: NSData.Base64EncodingOptions(rawValue: 0))
        return base64String
    }
    
    /// EZSE: Cut string from integerIndex to the end
    public subscript(integerIndex: Int) -> Character {
        let index = self.index(startIndex, offsetBy: integerIndex)
        return self[index]
    }
    
    /// EZSE: Cut string from range
    public subscript(integerRange: Range<Int>) -> String {
        let start = self.index(startIndex, offsetBy: integerRange.lowerBound)
        let end = self.index(startIndex, offsetBy: integerRange.upperBound)
        return String(self[start..<end])
    }
    
    /// EZSE: Cut string from closedrange
    public subscript(integerClosedRange: ClosedRange<Int>) -> String {
        return self[integerClosedRange.lowerBound..<(integerClosedRange.upperBound + 1)]
    }
    
    /// EZSE: Counts number of instances of the input inside String
    public func count(_ substring: String) -> Int {
        return components(separatedBy: substring).count - 1
    }
    
    /// EZSE: Capitalizes first character of String
    public mutating func capitalizeFirst() {
        guard self.count > 0 else { return }
        self.replaceSubrange(startIndex...startIndex, with: String(self[startIndex]).capitalized)
    }
    
    /// EZSE: Capitalizes first character of String, returns a new string
    public func capitalizedFirst() -> String {
        guard self.count > 0 else { return self }
        var result = self
        
        result.replaceSubrange(startIndex...startIndex, with: String(self[startIndex]).capitalized)
        return result
    }
    
    /// EZSE: Uppercases first 'count' characters of String
    public mutating func uppercasePrefix(_ count: Int) {
        guard self.count > 0 && count > 0 else { return }
        self.replaceSubrange(startIndex..<self.index(startIndex, offsetBy: min(count, length)),
                             with: String(self[startIndex..<self.index(startIndex, offsetBy: min(count, length))]).uppercased())
    }
    
    /// EZSE: Uppercases first 'count' characters of String, returns a new string
    public func uppercasedPrefix(_ count: Int) -> String {
        guard self.count > 0 && count > 0 else { return self }
        var result = self
        result.replaceSubrange(startIndex..<self.index(startIndex, offsetBy: min(count, length)),
                               with: String(self[startIndex..<self.index(startIndex, offsetBy: min(count, length))]).uppercased())
        return result
    }
    
    /// EZSE: Uppercases last 'count' characters of String
    public mutating func uppercaseSuffix(_ count: Int) {
        guard self.count > 0 && count > 0 else { return }
        self.replaceSubrange(self.index(endIndex, offsetBy: -min(count, length))..<endIndex,
                             with: String(self[self.index(endIndex, offsetBy: -min(count, length))..<endIndex]).uppercased())
    }
    
    /// EZSE: Uppercases last 'count' characters of String, returns a new string
    public func uppercasedSuffix(_ count: Int) -> String {
        guard self.count > 0 && count > 0 else { return self }
        var result = self
        result.replaceSubrange(self.index(endIndex, offsetBy: -min(count, length))..<endIndex,
                               with: String(self[self.index(endIndex, offsetBy: -min(count, length))..<endIndex]).uppercased())
        return result
    }
    
    /// EZSE: Uppercases string in range 'range' (from range.startIndex to range.endIndex)
    public mutating func uppercase(range: CountableRange<Int>) {
        let from = max(range.lowerBound, 0), to = min(range.upperBound, length)
        guard self.count > 0 && (0..<length).contains(from) else { return }
        self.replaceSubrange(self.index(startIndex, offsetBy: from)..<self.index(startIndex, offsetBy: to),
                             with: String(self[self.index(startIndex, offsetBy: from)..<self.index(startIndex, offsetBy: to)]).uppercased())
    }
    
    /// EZSE: Uppercases string in range 'range' (from range.startIndex to range.endIndex), returns new string
    public func uppercased(range: CountableRange<Int>) -> String {
        let from = max(range.lowerBound, 0), to = min(range.upperBound, length)
        guard self.count > 0 && (0..<length).contains(from) else { return self }
        var result = self
        result.replaceSubrange(self.index(startIndex, offsetBy: from)..<self.index(startIndex, offsetBy: to),
                               with: String(self[self.index(startIndex, offsetBy: from)..<self.index(startIndex, offsetBy: to)]).uppercased())
        return result
    }
    
    /// EZSE: Lowercases first character of String
    public mutating func lowercaseFirst() {
        guard self.count > 0 else { return }
        self.replaceSubrange(startIndex...startIndex, with: String(self[startIndex]).lowercased())
    }
    
    /// EZSE: Lowercases first character of String, returns a new string
    public func lowercasedFirst() -> String {
        guard self.count > 0 else { return self }
        var result = self
        result.replaceSubrange(startIndex...startIndex, with: String(self[startIndex]).lowercased())
        return result
    }
    
    /// EZSE: Lowercases first 'count' characters of String
    public mutating func lowercasePrefix(_ count: Int) {
        guard self.count > 0 && count > 0 else { return }
        self.replaceSubrange(startIndex..<self.index(startIndex, offsetBy: min(count, length)),
                             with: String(self[startIndex..<self.index(startIndex, offsetBy: min(count, length))]).lowercased())
    }
    
    /// EZSE: Lowercases first 'count' characters of String, returns a new string
    public func lowercasedPrefix(_ count: Int) -> String {
        guard self.count > 0 && count > 0 else { return self }
        var result = self
        result.replaceSubrange(startIndex..<self.index(startIndex, offsetBy: min(count, length)),
                               with: String(self[startIndex..<self.index(startIndex, offsetBy: min(count, length))]).lowercased())
        return result
    }
    
    /// EZSE: Lowercases last 'count' characters of String
    public mutating func lowercaseSuffix(_ count: Int) {
        guard self.count > 0 && count > 0 else { return }
        self.replaceSubrange(self.index(endIndex, offsetBy: -min(count, length))..<endIndex,
                             with: String(self[self.index(endIndex, offsetBy: -min(count, length))..<endIndex]).lowercased())
    }
    
    /// EZSE: Lowercases last 'count' characters of String, returns a new string
    public func lowercasedSuffix(_ count: Int) -> String {
        guard self.count > 0 && count > 0 else { return self }
        var result = self
        result.replaceSubrange(self.index(endIndex, offsetBy: -min(count, length))..<endIndex,
                               with: String(self[self.index(endIndex, offsetBy: -min(count, length))..<endIndex]).lowercased())
        return result
    }
    
    /// EZSE: Lowercases string in range 'range' (from range.startIndex to range.endIndex)
    public mutating func lowercase(range: CountableRange<Int>) {
        let from = max(range.lowerBound, 0), to = min(range.upperBound, length)
        guard self.count > 0 && (0..<length).contains(from) else { return }
        self.replaceSubrange(self.index(startIndex, offsetBy: from)..<self.index(startIndex, offsetBy: to),
                             with: String(self[self.index(startIndex, offsetBy: from)..<self.index(startIndex, offsetBy: to)]).lowercased())
    }
    
    /// EZSE: Lowercases string in range 'range' (from range.startIndex to range.endIndex), returns new string
    public func lowercased(range: CountableRange<Int>) -> String {
        let from = max(range.lowerBound, 0), to = min(range.upperBound, length)
        guard self.count > 0 && (0..<length).contains(from) else { return self }
        var result = self
        result.replaceSubrange(self.index(startIndex, offsetBy: from)..<self.index(startIndex, offsetBy: to),
                               with: String(self[self.index(startIndex, offsetBy: from)..<self.index(startIndex, offsetBy: to)]).lowercased())
        return result
    }
    
    /// EZSE: Counts whitespace & new lines
    @available(*, deprecated, renamed: "isBlank")
    public func isOnlyEmptySpacesAndNewLineCharacters() -> Bool {
        let characterSet = CharacterSet.whitespacesAndNewlines
        let newText = self.trimmingCharacters(in: characterSet)
        return newText.isEmpty
    }
    
    /// EZSE: Checks if string is empty or consists only of whitespace and newline characters
    public var isBlank: Bool {
        let trimmed = trimmingCharacters(in: .whitespacesAndNewlines)
        return trimmed.isEmpty
    }
    
    /// EZSE: Trims white space and new line characters
    public mutating func trim() {
        self = self.trimmed()
    }
    
    /// EZSE: Trims white space and new line characters, returns a new string
    public func trimmed() -> String {
        return self.trimmingCharacters(in: .whitespacesAndNewlines)
    }
    
    /// EZSE: Position of begining character of substing
    public func positionOfSubstring(_ subString: String, caseInsensitive: Bool = false, fromEnd: Bool = false) -> Int {
        if subString.isEmpty {
            return -1
        }
        var searchOption = fromEnd ? NSString.CompareOptions.anchored : NSString.CompareOptions.backwards
        if caseInsensitive {
            searchOption.insert(NSString.CompareOptions.caseInsensitive)
        }
        if let range = self.range(of: subString, options: searchOption), !range.isEmpty {
            return self.distance(from: self.startIndex, to: range.lowerBound)
        }
        return -1
    }
    
    /// EZSE: split string using a spearator string, returns an array of string
    public func split(_ separator: String) -> [String] {
        return self.components(separatedBy: separator).filter {
            !$0.trimmed().isEmpty
        }
    }
    
    /// EZSE: split string with delimiters, returns an array of string
    public func split(_ characters: CharacterSet) -> [String] {
        return self.components(separatedBy: characters).filter {
            !$0.trimmed().isEmpty
        }
    }
    
    /// EZSE : Returns count of words in string
    public var countofWords: Int {
        let regex = try? NSRegularExpression(pattern: "\\w+", options: NSRegularExpression.Options())
        return regex?.numberOfMatches(in: self, options: NSRegularExpression.MatchingOptions(), range: NSRange(location: 0, length: self.length)) ?? 0
    }
    
    /// EZSE : Returns count of paragraphs in string
    public var countofParagraphs: Int {
        let regex = try? NSRegularExpression(pattern: "\\n", options: NSRegularExpression.Options())
        let str = self.trimmingCharacters(in: CharacterSet.whitespacesAndNewlines)
        return (regex?.numberOfMatches(in: str, options: NSRegularExpression.MatchingOptions(), range: NSRange(location: 0, length: str.length)) ?? -1) + 1
    }
    
    internal func rangeFromNSRange(_ nsRange: NSRange) -> Range<String.Index>? {
        
        let from16 = utf16.index(utf16.startIndex, offsetBy: nsRange.location)
        let to16 = utf16.index(from16, offsetBy: nsRange.length)
        if let from = String.Index(from16, within: self),
            let to = String.Index(to16, within: self) {
            return from ..< to
        }
        return nil
    }
    
    /// EZSE: Find matches of regular expression in string
    public func matchesForRegexInText(_ regex: String!) -> [String] {
        let regex = try? NSRegularExpression(pattern: regex, options: [])
        let results = regex?.matches(in: self, options: [], range: NSRange(location: 0, length: self.length)) ?? []
        return results.map { String(self[self.rangeFromNSRange($0.range)!]) }
    }
    
    /// EZSE: Checks if String contains Email
    public var isEmail: Bool {
        let dataDetector = try? NSDataDetector(types: NSTextCheckingResult.CheckingType.link.rawValue)
        let firstMatch = dataDetector?.firstMatch(in: self, options: NSRegularExpression.MatchingOptions.reportCompletion, range: NSRange(location: 0, length: length))
        return (firstMatch?.range.location != NSNotFound && firstMatch?.url?.scheme == "mailto")
    }
    
    /// EZSE: Returns if String is a number
    public func isNumber() -> Bool {
        return NumberFormatter().number(from: self) != nil ? true : false
    }
    
    /// EZSE: Extracts URLS from String
    public var extractURLs: [URL] {
        var urls: [URL] = []
        let detector: NSDataDetector?
        do {
            detector = try NSDataDetector(types: NSTextCheckingResult.CheckingType.link.rawValue)
        } catch _ as NSError {
            detector = nil
        }
        
        let text = self
        
        if let detector = detector {
            detector.enumerateMatches(in: text,
                                      options: [],
                                      range: NSRange(location: 0, length: text.count),
                                      using: { (result: NSTextCheckingResult?, _, _) -> Void in
                if let result = result, let url = result.url {
                    urls.append(url)
                }
            })
        }
        
        return urls
    }
    
    /// EZSE: Checking if String contains input with comparing options
    public func contains(_ find: String, compareOption: NSString.CompareOptions) -> Bool {
        return self.range(of: find, options: compareOption) != nil
    }
    
    /// EZSE: Converts String to Int
    public func toInt() -> Int? {
        if let num = NumberFormatter().number(from: self) {
            return num.intValue
        } else {
            return nil
        }
    }
    
    /// EZSE: Converts String to Double
    public func toDouble() -> Double? {
        if let num = NumberFormatter().number(from: self) {
            return num.doubleValue
        } else {
            return nil
        }
    }
    
    /// EZSE: Converts String to Float
    public func toFloat() -> Float? {
        if let num = NumberFormatter().number(from: self) {
            return num.floatValue
        } else {
            return nil
        }
    }
    
    /// EZSE: Converts String to Bool
    public func toBool() -> Bool? {
        let trimmedString = trimmed().lowercased()
        if trimmedString == "true" || trimmedString == "false" {
            return (trimmedString as NSString).boolValue
        }
        return nil
    }
    
    ///EZSE: Returns the first index of the occurency of the character in String
    public func getIndexOf(_ char: Character) -> Int? {
        for (index, c) in self.enumerated() where c == char {
            return index
        }
        return nil
    }
    
    /// EZSE: Converts String to NSString
    public var toNSString: NSString { return self as NSString }
    
    #if os(iOS)
    
    ///EZSE: Returns bold NSAttributedString
    public func bold() -> NSAttributedString {
        let boldString = NSMutableAttributedString(string: self, attributes: [NSAttributedString.Key.font: UIFont.boldSystemFont(ofSize: UIFont.systemFontSize)])
        return boldString
    }
    
    #endif
    
    #if os(iOS)

    ///EZSE: Returns underlined NSAttributedString
    public func underline() -> NSAttributedString {
        let underlineString = NSAttributedString(string: self, attributes: [NSAttributedString.Key.underlineStyle: NSUnderlineStyle.single.rawValue])
        return underlineString
    }
    
    #endif
    
    #if os(iOS)
    
    ///EZSE: Returns italic NSAttributedString
    public func italic() -> NSAttributedString {
        let italicString = NSMutableAttributedString(string: self, attributes: [NSAttributedString.Key.font: UIFont.italicSystemFont(ofSize: UIFont.systemFontSize)])
        return italicString
    }
    
    #endif
    
    #if os(iOS)
    
    ///EZSE: Returns hight of rendered string
    public func height(_ width: CGFloat, font: UIFont, lineBreakMode: NSLineBreakMode?) -> CGFloat {
        var attrib: [NSAttributedString.Key: Any] = [NSAttributedString.Key.font: font]
        if lineBreakMode != nil {
            let paragraphStyle = NSMutableParagraphStyle()
            paragraphStyle.lineBreakMode = lineBreakMode!
            attrib.updateValue(paragraphStyle, forKey: NSAttributedString.Key.paragraphStyle)
        }
        let size = CGSize(width: width, height: CGFloat(Double.greatestFiniteMagnitude))
        return ceil((self as NSString).boundingRect(with: size, options: NSStringDrawingOptions.usesLineFragmentOrigin, attributes: attrib, context: nil).height)
    }
    
    #endif
    
    #if os(iOS) || os(tvOS)
    
    ///EZSE: Returns NSAttributedString
    public func color(_ color: UIColor) -> NSAttributedString {
        let colorString = NSMutableAttributedString(string: self, attributes: [NSAttributedString.Key.foregroundColor: color])
        return colorString
    }
    
    ///EZSE: Returns NSAttributedString
    public func colorSubString(_ subString: String, color: UIColor) -> NSMutableAttributedString {
        var start = 0
        var ranges: [NSRange] = []
        while true {
            let range = (self as NSString).range(of: subString, options: NSString.CompareOptions.literal, range: NSRange(location: start, length: (self as NSString).length - start))
            if range.location == NSNotFound {
                break
            } else {
                ranges.append(range)
                start = range.location + range.length
            }
        }
        let attrText = NSMutableAttributedString(string: self)
        for range in ranges {
            attrText.addAttribute(NSAttributedString.Key.foregroundColor, value: color, range: range)
        }
        return attrText
    }
    
    #endif
    
    /// EZSE: Checks if String contains Emoji
    public func includesEmoji() -> Bool {
        for i in 0...length {
            let c: unichar = (self as NSString).character(at: i)
            if (0xD800 <= c && c <= 0xDBFF) || (0xDC00 <= c && c <= 0xDFFF) {
                return true
            }
        }
        return false
    }
    
    #if os(iOS)
    
    /// EZSE: copy string to pasteboard
    public func addToPasteboard() {
        let pasteboard = UIPasteboard.general
        pasteboard.string = self
    }
    
    #endif
    
    // EZSE: URL encode a string (percent encoding special chars)
    public func urlEncoded() -> String {
        return self.addingPercentEncoding(withAllowedCharacters: .urlHostAllowed)!
    }
    
    // EZSE: URL encode a string (percent encoding special chars) mutating version
    mutating func urlEncode() {
        self = urlEncoded()
    }
    
    // EZSE: Removes percent encoding from string
    public func urlDecoded() -> String {
        return removingPercentEncoding ?? self
    }
    
    // EZSE : Mutating versin of urlDecoded
    mutating func urlDecode() {
        self = urlDecoded()
    }
}
